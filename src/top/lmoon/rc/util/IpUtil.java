/**
 * 
 */
package top.lmoon.rc.util;

/**
 * @author LMoon
 * @date 2017年7月4日
 * 
 */
public class IpUtil {

	/**
	 * 【分析IP地址的组成特点：250-255、200-249、0-199。 这三种情况可以分开考虑， 1.
	 * 250-255：特点：三位数，百位是2，十位是5，个位是0~5，用正则表达式可以写成：25[0-5] 2.
	 * 200-249：特点：三位数，百位是2，十位是0~4，个位是0~9，用正则表达式可以写成：2[0-4]\d 3.
	 * 0-199：这个可以继续分拆，这样写起来更加简单明了. 3.1. 0-9： 特点：一位数，个位是0~9，用正则表达式可以写成：\d 3.2.
	 * 10-99： 特点：二位数，十位是1~9，个位是0~9，用正则表达式可以写成：[1-9]\d 3.3.
	 * 100-199：特点：三位数，百位是1，十位是0~9，个位是0~9，用正则表达式可以写成：1\d{2}
	 * 
	 * 于是0-99的正则表达式可以合写为[1-9]?\d，那么0-199用正则表达式就可以写成(1\d{2})|([1-9]?\d)，这样0~255的正则表达式就可以写成(25[0-5]|2[0-4]\d|((1\d{2})|([1-9]?\d)))】
	 * （注：用小括号的时候会匹配到分组里面去，加上?:就不会捕获到分组了.非捕获性分组语法为(?:pattern),即将pattern部分组合成一个可统一操作的组合项，但不把这部分内容当作子匹配捕获.）
	 * 
	 * @param ip
	 * @return
	 */
	public static boolean checkIp(String ip) {
		String regex = "((?:(?:25[0-5]|2[0-4]\\d|((1\\d{2})|([1-9]?\\d)))\\.){3}(?:25[0-5]|2[0-4]\\d|((1\\d{2})|([1-9]?\\d))))";
		return ip.matches(regex);
	}

	public static void main(String[] args) {
		System.out.println(checkIp("127.0.0.1"));
	}
}
